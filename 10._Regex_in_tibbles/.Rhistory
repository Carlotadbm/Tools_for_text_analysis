quijote$word %>%
str_view("^y.", match = T)
quijote$word %>%
str_view("y$", match = T)
#You can also match the boundary between words with \b
quijote$word %>%
str_view(".\\b", match = T)
verne
#\s: matches any whitespace (e.g. space, tab, newline).
verne$text %>%
str_view_all(".\\b", match = T)
#\s: matches any whitespace (e.g. space, tab, newline).
verne$text %>%
str_view_all(".\\s.", match = T)
#\d: matches any digit.
verne$text %>%
str_view_all("^\\d.", match = T)
#Character Classes or Character Sets
quijote$word %>%
str_view("h[iu]e", match = T)
#Character Classes or Character Sets
quijote$word %>%
str_view("[iu]e", match = T)
quijote$word %>%
str_view("[^q][iu]e", match = T)
#Negated Character Classes
quijote$word %>%
str_view("[^qg][iu]e", match = T)
verne$text %>%
str_view("[aeiouàèôâê]", match = T)
library(tidytext)
verne %>%
unnest_tokens(sentences, text, token = "sentences")
verne %>%
unnest_tokens(sentences, text, token = "sentences", to_lower = FALSE)
verne <- verne %>%
unnest_tokens(sentences, text, token = "sentences", to_lower = FALSE)
verne$sentences %>%
str_view_all("[aeiouàèôâê]", match = T)
verne$sentences %>%
str_view_all("[aeiou]+", match = T)
verne$sentences %>%
str_view_all("l[aeiou]+", match = T)
verne$sentences %>%
str_view_all("l[aeiou]?", match = T)
verne$sentences %>%
str_view_all("l[aeiou]*", match = T)
verne$sentences %>%
str_view_all("l[aeiou]?", match = T)
verne$sentences %>%
str_view_all(x, "l{2}")
verne$sentences %>%
str_view_all("l{2}")
verne$sentences %>%
str_view_all("[aeiou]{2,}") #dos o más veces
quijote$word %>%
str_view_all("[aeiou]{2,}") #dos o más veces
verne$sentences %>%
str_view_all("l{2}", match = TRUE) #dos veces
quijote$word %>%
str_view_all("[aeiou]{2,}", match = TRUE) #dos o más veces
quijote$word %>%
str_view_all("[rst]{2,}", match = TRUE) #dos o más veces
quijote$word %>%
str_view_all("[aeiourst]{2,}", match = TRUE) #dos o más veces
quijote$word %>%
str_view_all("[eorst]{2,}", match = TRUE) #dos o más veces
quijote$word %>%
str_view_all("[eorst]{2,3}", match = TRUE) #dos o más veces
#Alternation
#le, la, les, un, unes, des
verne$sentences %>%
str_view_all("le|la|les|un|unes|des", match = TRUE) #dos veces
verne$sentences %>%
str_view_all("\\b(le|la|les|un|unes|des)\\b", match = TRUE) #dos veces
#Earlier, you learned about parentheses as a way to disambiguate complex expressions.
#Parentheses also create a numbered capturing group (number 1, 2 etc.).
#A capturing group stores the part of the string matched by the part of the regular expression
#inside the parentheses.
#You can refer to the same text as previously matched by a capturing group with backreferences,
#like \1, \2 etc.
#For example, the following regular expression finds all fruits that have a
#repeated pair of letters.
verne$sentences %>%
str_view_all("(..)", match = TRUE) #dos veces
#Earlier, you learned about parentheses as a way to disambiguate complex expressions.
#Parentheses also create a numbered capturing group (number 1, 2 etc.).
#A capturing group stores the part of the string matched by the part of the regular expression
#inside the parentheses.
#You can refer to the same text as previously matched by a capturing group with backreferences,
#like \1, \2 etc.
#For example, the following regular expression finds all fruits that have a
#repeated pair of letters.
verne$sentences %>%
str_view_all("(..)\\1", match = TRUE) #dos veces
quijote$word %>%
str_view_all("(.).\\1", match = TRUE) #dos veces
#Detect matches
x <- c("apple", "banana", "pear")
str_detect(x, "e")
str_detect_all(x, "a")
quijote$word %>%
str_detect("^a")
quijote %>%
filter(str_detect(word, "^a"))
quijote$word %>%
str_detect("^a") %>%
sum
quijote$word %>%
str_detect("^a") %>%
sum()
quijote$word %>%
str_detect("^a") %>%
mean()
quijote$word %>%
str_detect("^a") %>%
summary()
quijote$word %>%
str_detect("^a") %>%
median()
#When you have complex logical conditions (e.g. match a or b but not c unless d) it’s often easier to combine multiple str_detect()
#calls with logical operators, rather than trying to create a single regular expression.
#For example, here are two ways to find all words that don’t contain any vowels:
# Find all words containing at least one vowel, and negate
quijote %>%
filter(str_detect(word, "[aeiou]"))
#When you have complex logical conditions (e.g. match a or b but not c unless d) it’s often easier to combine multiple str_detect()
#calls with logical operators, rather than trying to create a single regular expression.
#For example, here are two ways to find all words that don’t contain any vowels:
# Find all words containing at least one vowel, and negate
quijote %>%
filter(!str_detect(word, "[aeiou]"))
#When you have complex logical conditions (e.g. match a or b but not c unless d) it’s often easier to combine multiple str_detect()
#calls with logical operators, rather than trying to create a single regular expression.
#For example, here are two ways to find all words that don’t contain any vowels:
# Find all words containing at least one vowel, and negate
quijote %>%
filter(!str_detect(word, "[aeiouáé]"))
#str_count() tells you how many matches there are in a string:
#Good for using in a mutate
quijote$word %>%
str_count("^a")
#str_count() tells you how many matches there are in a string:
#Good for using in a mutate
quijote$word %>%
str_count("a")
#str_count() tells you how many matches there are in a string:
#Good for using in a mutate
quijote$word %>%
str_count("s")
#str_count() tells you how many matches there are in a string:
#Good for using in a mutate
quijote$word %>%
str_count("a")
quijote %>%
mutate(number_a = str_count("a"))
#str_count() tells you how many matches there are in a string:
#Good for using in a mutate
quijote$word %>%
str_count("a") %>%
head()
quijote %>%
mutate(number_a = str_count(word, "a"))
quijote$word %>%
str_count("[aeiouáéíóúü]") %>%
mean()
str_detect(words, "(^x|x$)")
str_view(words, "(^x|x$)", match = T)
str_view(words, "^x", match = T)
#Note that matches never overlap. For example, in "abababa",
#how many times will the pattern "aba" match? Regular expressions say two, not three:
str_count("abababa", "aba")
str_view_all("abababa", "aba")
colours <- c("red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match
has_colour <- str_subset(sentences, colour_match)
matches <- str_extract(has_colour, colour_match)
matches
has_colour
matches
#str_extract()
verne %>%
mutate(starts_with_vowel = str_extract(sentences, "^[^aeiou]+$"))
#str_extract()
verne %>%
mutate(starts_with_vowel = str_extract(sentences, "^[^AEIOU]+$"))
#str_extract()
verne %>%
mutate(starts_with_vowel = str_extract(sentences, "^[AEIOU]"))
#str_extract()
verne %>%
mutate(fem_noun = str_extract(sentences, "\\bla\\s.+\\b"))
#str_extract()
verne %>%
mutate(fem_noun = str_extract(sentences, "\\bla\\b\\s.+\\b"))
#str_extract()
verne %>%
mutate(fem_noun = str_extract(sentences, "\\bla\\b\\s\\w+\\b"))
verne %>%
mutate(fem_noun = str_extract_all(sentences, "\\bla\\b\\s\\w+\\b", simplify = TRUE))
#replace
quijote$word %>%
str_replace("[aeiouáéíóú]", "i")
quijote$word %>%
str_replace_all("[aeouáéíóú]", "i")
#in mutate
quijote %>%
mutate(word = str_replace_all("[aeouáéíóú]", "i"))
#in mutate
quijote %>%
mutate(word = str_replace_all(word, "[aeouáéíóú]", "i"))
#multiple replacements
quijote %>%
mutate(word = str_replace_all(word, c("[aeou]" = "i", "[áéóú]" = "í")))
#multiple replacements
quijote %>%
mutate(word = str_replace_all(word, c("qu" = "k", "[aeouáéíóú]" = "i")))
#Instead of replacing with a fixed string you can use backreferences to insert
#components of the match. In the following code, I flip the order of the second and third words.
quijote %>%
mutate(word = str_replace_all(word, "([aeiouáéíóú])([bcdfghjklmñpqrstvwxzy])", "\\2 \\1"))
#Instead of replacing with a fixed string you can use backreferences to insert
#components of the match. In the following code, I flip the order of the second and third words.
quijote %>%
mutate(word = str_replace_all(word, "([bcdfghjklmñpqrstvwxzy])([aeiouáéíóú])", "\\2 \\1"))
#Instead of replacing with a fixed string you can use backreferences to insert
#components of the match. In the following code, I flip the order of the second and third words.
quijote %>%
mutate(word = str_replace_all(word, "([bcdfghjklmñpqrstvwxzy])([aeiouáéíóú])", "\\2\\1"))
#Instead of replacing with a fixed string you can use backreferences to insert
#components of the match. In the following code, I flip the order of the second and third words.
quijote %>%
mutate(word = str_replace_all(inverted_word, "([bcdfghjklmñpqrstvwxzy])([aeiouáéíóú])", "\\2\\1"))
#Instead of replacing with a fixed string you can use backreferences to insert
#components of the match. In the following code, I flip the order of the second and third words.
quijote %>%
mutate(inverted_word = str_replace_all(word, "([bcdfghjklmñpqrstvwxzy])([aeiouáéíóú])", "\\2\\1"))
#Define a word in Spanish
quijote$word %>%
str_view("[a-zñáéíóúüA-ZÑÁÉÍÓÚÜ]")
#Define a word in Spanish
quijote$word %>%
str_view("\\b[a-zñáéíóúüA-ZÑÁÉÍÓÚÜ]\\b")
#Define a word in Spanish
quijote$word %>%
str_view("\\b[a-zñáéíóúüA-ZÑÁÉÍÓÚÜ]*\\b")
?str_view_all
setwd("~/Documents/swirl_cursos")
library(swirlify)
#Create a lesson
new_lesson("9. Regular expressions with stringr", "Tools for text analysis") #this creates the directory structure
##Message Questions
#String of text in the R console for the student to read.
#Once the student presses enter, swirl will move on to the next question.
wq_message() #en la consola
##Command questions
#They prompt the student to type an expression into the R console.
#The CorrectAnswer is entered into the console if the student uses the skip() function.
#The Hint is displayed to the student if they don’t get the question right.
#The AnswerTests determine whether or not the student answered the question correctly.
#See the answer testing section for more information.
wq_command()
#Looking for a literal sequence
quijote$word %>%
str_view("or")
#Looking for a literal sequence
quijote$word %>%
str_view("os", match = T)
#Multiple choice questions
#They present a selection of options to the student.
#These options are presented in a different order every time the question is seen.
#The AnswerChoices should be a semicolon separated string of choices that the student
#will have to choose from.
wq_multiple()
quijote$word %>%
str_view("^z", match = TRUE)
quijote$word %>%
str_view("^ç", match = TRUE)
quijote$word %>%
str_view("^f", match = TRUE)
#Special characters must be escaped in order to get a literal interpretation, with a backslash
#In R you must use two backslashes
verne$sentences %>%
str_view("\\.", match = TRUE)
#Special characters must be escaped in order to get a literal interpretation, with a backslash
#In R you must use two backslashes
verne$sentences %>%
str_view_all("\\.", match = TRUE)
#You can also match the boundary between words with \b, must be escaped
verne$sentences %>%
str_view_all(".\\b", match = TRUE)
#\s: matches any whitespace (e.g. space, tab, newline).
verne$sentences %>%
str_view_all(".\\s.", match = TRUE)
#\s: matches any whitespace (e.g. space, tab, newline).
verne$sentences %>%
str_view_all(".\\s", match = TRUE)
verne$sentences %>%
str_view_all("[æœ]+", match = TRUE)
verne$sentences %>%
str_view_all("[æœ]", match = TRUE)
verne$sentences %>%
str_view_all("æ", match = TRUE)
verne$sentences %>%
str_view_all("l[aeiouàèùéâêîôûëïüÿ]?s", match = TRUE)
verne$sentences %>%
str_view_all("[aeiouàèùéâêîôûëïüÿ]+", match = TRUE)
verne$sentences %>%
str_view_all("l[aeiouàèùéâêîôûëïüÿ]?s", match = TRUE)
verne$sentences %>%
str_view_all("n[aeiouàèùéâêîôûëïüÿ]?s", match = TRUE)
verne$sentences %>%
str_view_all("r[aeiouàèùéâêîôûëïüÿ]?t", match = TRUE)
verne$sentences %>%
str_view_all("r[aeiouàèùéâêîôûëïüÿ]+t", match = TRUE)
verne$sentences %>%
str_view_all("r+[aeiouàèùéâêîôûëïüÿ]+t", match = TRUE)
verne$sentences %>%
str_view_all("l[aeiouàèùéâêîôûëïüÿ]t", match = TRUE)
verne$sentences %>%
str_view_all("l[aeiouàèùéâêîôûëïüÿ]+", match = TRUE)
quijote$word %>%
str_view_all("[eorst]{2,}", match = TRUE) #dos o más veces
quijote$word %>%
str_view("[eorst]{2,}", match = TRUE) #dos o más veces
quijote$word %>%
str_view_all("l{2}", match = TRUE) #dos veces
#Earlier, you learned about parentheses as a way to disambiguate complex expressions.
#Parentheses also create a numbered capturing group (number 1, 2 etc.).
#A capturing group stores the part of the string matched by the part of the regular expression
#inside the parentheses.
#You can refer to the same text as previously matched by a capturing group with backreferences,
#like \1, \2 etc.
#For example, the following regular expression finds all fruits that have a
#repeated pair of letters.
verne$sentences %>%
str_view_all("(..)\\1", match = TRUE) #dos veces
quijote$word %>%
str_view_all("(.).\\1", match = TRUE) #dos veces
#Multiple choice questions
#They present a selection of options to the student.
#These options are presented in a different order every time the question is seen.
#The AnswerChoices should be a semicolon separated string of choices that the student
#will have to choose from.
wq_multiple()
#Create a lesson
new_lesson("10. Regex in tibbles", "Tools for text analysis") #this creates the directory structure
##Message Questions
#String of text in the R console for the student to read.
#Once the student presses enter, swirl will move on to the next question.
wq_message() #en la consola
#Detect matches
#str_detect() returns a logical vector
##Because logical vectors  can be used in a numeric context, FALSE becomes 0 and TRUE
#becomes 1.
quijote$word %>%
str_detect("^a") %>%
sum()
#Detect matches
#str_detect() returns a logical vector
##Because logical vectors  can be used in a numeric context, FALSE becomes 0 and TRUE
#becomes 1.
quijote$word %>%
str_detect("^a") #%>%
##Command questions
#They prompt the student to type an expression into the R console.
#The CorrectAnswer is entered into the console if the student uses the skip() function.
#The Hint is displayed to the student if they don’t get the question right.
#The AnswerTests determine whether or not the student answered the question correctly.
#See the answer testing section for more information.
wq_command()
#Detect matches
#str_detect() returns a logical vector
##Because logical vectors  can be used in a numeric context, FALSE becomes 0 and TRUE
#becomes 1.
quijote$word %>%
str_detect("\\ba") %>%
sum()
quijote$word %>%
str_detect("^a") %>%
sum()
str_detect(quijote$word, "^a") %>%
sum()
98/1396
quijote$word %>%
str_detect("^a") %>%
mean()
quijote %>%
mutate(starts_a = str_detect(word, "^a"))
#When you have complex logical conditions (e.g. match a or b but not c unless d) it’s often easier to combine multiple str_detect()
#calls with logical operators, rather than trying to create a single regular expression.
#For example, here are two ways to find all words that don’t contain any vowels:
# Find all words containing at least one vowel, and negate
quijote %>%
filter(!str_detect(word, "[aeiou]"))
no_vowels_1 <- quijote %>%
!str_detect(word, "[aeiou]")
no_vowels_1 <- quijote %>%
filter(!str_detect(word, "[aeiou]"))
# Find all words consisting only of consonants (non-vowels)
no_vowels_3 <-   quijote %>%
filter(str_detect(words, "[^aeiou]"))
# Find all words consisting only of consonants (non-vowels)
no_vowels_3 <-   quijote %>%
filter(str_detect(words, "^[^aeiou]+$"))
# Find all words consisting only of consonants (non-vowels)
no_vowels_3 <-   quijote %>%
filter(str_detect(wors, "[^aeiou]"))
# Find all words consisting only of consonants (non-vowels)
no_vowels_3 <-   quijote %>%
filter(str_detect(word, "[^aeiou]"))
identical(no_vowels_1, no_vowels_3)
quijote$word %>% str_detect("[^aeiou]"))
quijote$word %>% str_detect("[^aeiou]")
quijote$word %>% str_view("[^aeiou]")
##Command questions
#They prompt the student to type an expression into the R console.
#The CorrectAnswer is entered into the console if the student uses the skip() function.
#The Hint is displayed to the student if they don’t get the question right.
#The AnswerTests determine whether or not the student answered the question correctly.
#See the answer testing section for more information.
wq_command()
#str_count() tells you how many matches there are in a string:
#Good for using in a mutate
quijote$word %>%
str_count("a")
#Multiple choice questions
#They present a selection of options to the student.
#These options are presented in a different order every time the question is seen.
#The AnswerChoices should be a semicolon separated string of choices that the student
#will have to choose from.
wq_multiple()
#Note that matches never overlap. For example, in "abababa",
#how many times will the pattern "aba" match? Regular expressions say two, not three:
"abababa" %>% str_count("aba")
str_view_all("abababa", "aba")
#str_extract() extracts the exact match (not the string where it is found)
verne %>%
mutate(fem_noun = str_extract(sentences, "\\bla\\b\\s\\w+\\b"))
#all matches, in different columns
verne %>%
mutate(fem_noun = str_extract_all(sentences, "\\bla\\b\\s\\w+\\b", simplify = TRUE))
#in mutate
quijote %>%
mutate(word_i = str_replace(word, "[aeouáéíóú]", "i"))
quijote %>%
mutate(word_i = str_replace_all(word, "[aeouáéíóú]", "i"))
demo_lesson()
test_lesson()
test_lesson()
test_lesson()
test_lesson()
test_lesson()
demo_lesson()
demo_lesson()
demo_lesson()
setwd("~/Documents/swirl_cursos/Tools_for_text_analysis/10._Regex_in_tibbles")
library(tidyverse)
library(tidytext)
library(htmlwidgets)
quijote <- read_delim("quijote_freq.csv", delim = "\t")
demo_lesson()
swirl()
demo_lesson()
demo_lesson()
quijote
verne
str_detect(quijote$word, "^a")
str_detect(quijote$word, "^a") %>% sum()
str_detect(quijote$word, "^a") %>% mean()
quijote %>% mutate(starts_a = str_detect(word, "^a"))
quijote %>% filter(str_detect(word, "^a"))
quijote %>% filter(!str_detect(word, "[aeiouáéíóúü]"))
str_count(quijote$word, "a")
str_count(quijote$word, "a") %>% mean()
quijote %>% mutate(number_a = str_count(word, "a"))
str_count("abababa", "aba")
str_view_all("abababa", "aba")
verne %>% mutate(fem_noun = str_extract(sentences, "\bla\b\s\w+\b"))
verne %>% mutate(fem_noun = str_extract(sentences, "\\bla\\b\\s\\w+\\b"))
demo_lesson(15)
demo_lesson(15)
demo_lesson(20)
demo_lesson(22)
verne %>% mutate(fem_noun = str_extract(sentences, "\\bla\\b\\s\\w+\\b"))
demo_lesson(22)
verne %>% mutate(fem_noun = str_extract(sentences, "\\bla\\b\\s\\w+\\b"))
demo_lesson(22)
verne %>% mutate(fem_noun = str_extract(sentences, "\\bla\\b\\s\\w+\\b"))
verne %>% mutate(fem_noun = str_extract_all(sentences, "\\bla\\b\\s\\w+\\b", simplify = TRUE))
demo_lesson(22)
verne %>% mutate(fem_noun = str_extract(sentences, "\\bla\\b\\s\\w+\\b"))
verne %>% mutate(fem_noun = str_extract_all(sentences, "\\bla\\b\\s\\w+\\b", simplify = TRUE))
str_replace(quijote$word, "[aeouáéíóú]", "i")
quijote %>% mutate(word_i = str_replace(word, "[aeouáéíóú]", "i")
)
quijote %>% mutate(word_i = str_replace_all(word, "[aeouáéíóú]", "i"))
quijote %>% mutate(word = str_replace_all(word, "[aeouáéíóú]", "i"))
quijote %>% mutate(word_new = str_replace_all(word, c("[aeouáéíóú]" = "i", "qu" = "k")))
demo_lesson(34)
demo_lesson(31)
demo_lesson(28)
quijote %>% mutate(word = str_replace_all(word, "[aeouáéíóú]", "i"))
quijote %>% mutate(word_new = str_replace_all(word, c("qu" = "k", "[aeouáéíóú]" = "i")))
quijote %>% mutate(inverted_word = str_replace_all(word, "([bcdfghjklmñpqrstvwxzy])([aeiouáéíóúü])", "\\2\\1"))
quijote %>% mutate(inverted_word = str_replace_all(word, "([bcdfghjklmñpqrstvwxzy])([aeiouáéíóúü])", "\\2\\1"))
demo_lesson(31)
quijote %>% mutate(inverted_word = str_replace_all(word, "([bcdfghjklmñpqrstvwxzy])([aeiouáéíóúü])", "\\2\\1"))
demo_lesson(31)
quijote %>% mutate(inverted_word = str_replace_all(word, "([bcdfghjklmñpqrstvwxzy])([aeiouáéíóúü])", "\\2"))
quijote %>% mutate(inverted_word = str_replace_all(word, "([bcdfghjklmñpqrstvwxzy])([aeiouáéíóúü])", "\\2\\1"))
